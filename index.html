<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>גליל – לוח יריבות (מפה)</title>
  <style>
    :root{
      --bg0:#040812;--bg1:#071427;
      --glass:rgba(18,30,48,.55);--glass2:rgba(18,30,48,.38);
      --stroke:rgba(255,255,255,.10);--stroke2:rgba(58,167,255,.22);
      --text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.70);--muted2:rgba(255,255,255,.55);
      --accent:#3aa7ff;--accent2:#79d2ff;
      --good:#4ade80;--warn:#fbbf24;
    }
    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;color:var(--text);
      font-family:system-ui,-apple-system,"Segoe UI",Arial,"Noto Sans Hebrew",sans-serif;
      background:
        radial-gradient(1200px 600px at 70% 20%, rgba(58,167,255,.16), transparent 55%),
        radial-gradient(900px 500px at 20% 15%, rgba(121,210,255,.10), transparent 50%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow-x:hidden;
    }
    .bg{
      position:fixed; inset:0; pointer-events:none;
      background:url("assets/bg-tree.svg") center/cover no-repeat;
      opacity:.30; filter:saturate(1.05);
    }
    .bg::after{
      content:""; position:absolute; inset:0;
      background:radial-gradient(900px 600px at 50% 40%, rgba(0,0,0,.10), rgba(0,0,0,.65));
    }
    .wrap{position:relative; min-height:100%;}
    header{
      position:sticky; top:0; z-index:50;
      backdrop-filter:blur(10px);
      background:linear-gradient(90deg, rgba(10,18,32,.55), rgba(10,18,32,.35));
      border-bottom:1px solid var(--stroke);
    }
    .bar{
      max-width:1320px; margin:0 auto; padding:14px 18px;
      display:flex; gap:14px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
    .title{display:flex; flex-direction:column; gap:4px; min-width:260px;}
    .title h1{margin:0;font-size:22px;letter-spacing:.2px;}
    .title .sub{color:var(--muted);font-size:13px;}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border:1px solid var(--stroke);
      background:rgba(255,255,255,.03); border-radius:999px;
      color:var(--muted); font-size:12px; white-space:nowrap;
    }
    .pill a{color:var(--accent2);text-decoration:none;}
    .pill a:hover{text-decoration:underline;}

    main{
      max-width:1320px; margin:16px auto 26px; padding:0 14px;
      display:grid; grid-template-columns:420px 1fr; gap:16px;
    }

    .card{
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, var(--glass), rgba(7,15,26,.35));
      border-radius:18px;
      box-shadow:0 20px 70px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .cardHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--stroke);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .cardHeader h2{margin:0;font-size:16px;color:var(--text);}
    .cardHeader small{color:var(--muted2);font-size:12px;}
    .cardBody{padding:12px 14px 14px;}

    label{font-size:13px;color:var(--muted);}
    input[type="text"], select{
      width:100%; margin-top:6px; padding:10px 10px;
      border-radius:12px; border:1px solid var(--stroke);
      background:rgba(255,255,255,.03); color:var(--text);
      outline:none;
      color-scheme: dark; /* helps Windows dropdown */
    }
    input::placeholder{color:rgba(255,255,255,.45);}
    .row{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;}
    .row3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; margin-top:10px;}

    .chips{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;}
    .chip{
      cursor:pointer; user-select:none;
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.03);
      color:var(--muted); font-size:12px; transition:.15s ease;
    }
    .chip:hover{border-color:var(--stroke2); color:var(--text);}
    .chip.active{
      border-color:rgba(58,167,255,.55);
      background:rgba(58,167,255,.12);
      color:var(--text);
      box-shadow:0 0 0 3px rgba(58,167,255,.10) inset;
    }

    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    button{
      cursor:pointer;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:600;
      transition:.15s ease;
    }
    button:hover{border-color:var(--stroke2); background:rgba(58,167,255,.10);}
    button.primary{border-color:rgba(58,167,255,.55); background:rgba(58,167,255,.12);}
    button:disabled{opacity:.45; cursor:not-allowed;}

    .stats{
      margin-top:12px; padding:10px 12px;
      border-radius:14px; border:1px dashed rgba(255,255,255,.14);
      background:rgba(0,0,0,.15);
      color:var(--muted); font-size:12px; line-height:1.5;
    }

    .map{position:relative; min-height:720px;}
    .mapInner{
      position:relative; height:720px;
      border-radius:18px; overflow:hidden;
      border:1px solid var(--stroke);
      background:radial-gradient(700px 420px at 50% 50%, rgba(58,167,255,.10), rgba(0,0,0,.15));
    }
    .mapGrid{
      position:absolute; inset:0;
      background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,.07) 1px, transparent 0);
      background-size:22px 22px;
      opacity:.25;
    }
    .mapTitle{
      position:absolute; top:14px; right:14px; left:14px;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    .mapTitle h2{margin:0;font-size:18px;}
    .mapTitle .hint{color:var(--muted2);font-size:12px;text-align:left;}

    .node{
      position:absolute; width:210px; transform:translate(-50%,-50%);
      border-radius:16px; border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(15,26,42,.75), rgba(9,16,27,.55));
      box-shadow:0 16px 44px rgba(0,0,0,.35);
      padding:12px 12px 10px;
      cursor:pointer; transition:.16s ease;
    }
    .node:hover{border-color:rgba(58,167,255,.50); box-shadow:0 18px 52px rgba(0,0,0,.42);}
    .node .name{font-weight:800;font-size:14px;line-height:1.2;margin-bottom:6px;}
    .node .meta{color:var(--muted2);font-size:12px;display:flex;justify-content:space-between;gap:10px;}
    .node .cta{margin-top:8px;color:var(--accent2);font-size:12px;}
    .node.center{
      width:270px;
      border-color:rgba(58,167,255,.55);
      background:linear-gradient(180deg, rgba(35,86,120,.70), rgba(10,18,32,.55));
      box-shadow:0 26px 80px rgba(58,167,255,.10), 0 18px 64px rgba(0,0,0,.45);
    }
    .node.center .name{font-size:16px;}
    .meta2{font-size:12px; opacity:.9; margin-top:6px; color: rgba(210,240,255,0.92);}

    .line{position:absolute;height:1px;background:rgba(58,167,255,.16);transform-origin:0 50%;pointer-events:none;}

    table{
      width:100%;
      border-collapse:collapse;
      border-radius:14px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.12);
      overflow:hidden;
    }
    th,td{
      padding:10px 12px;
      font-size:14px;
      border-bottom:1px solid rgba(255,255,255,.06);
      vertical-align:middle;
    }
    th{
      text-align:right;
      color:rgba(255,255,255,.85);
      background:rgba(255,255,255,.04);
      position:sticky; top:0; z-index:1;
    }
    tr:hover td{background:rgba(58,167,255,.06);}
    .twoTables{display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px;}
    .muted{color:var(--muted2);}
    .err{
      margin-top:10px;padding:10px 12px;
      border:1px solid rgba(251,191,36,.35);
      border-radius:14px;
      background:rgba(251,191,36,.08);
      color:rgba(255,255,255,.90);
      font-size:12px; line-height:1.5;
    }

    /* Fix: dark dropdown options on Windows */
    select, option{ background-color: rgba(8,22,38,0.95); color: var(--text); }
    select:focus{ outline:2px solid rgba(94,212,255,0.55); outline-offset:2px; }

    /* Round navigation buttons */
    .roundRow{display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap;}
    .roundRow .btnMini{
      padding:8px 12px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(18,45,72,0.55);
      color:var(--text);
    }
    .roundRow .btnMini:hover{ background:rgba(18,45,72,0.75); }

    @media (max-width:1100px){
      main{grid-template-columns:1fr;}
      .mapInner{height:640px;}
      .map{min-height:640px;}
    }
    @media (max-width:560px){
      .node{width:180px;}
      .node.center{width:220px;}
      .row{grid-template-columns:1fr;}
      .row3{grid-template-columns:1fr;}
      th,td{font-size:12px;padding:9px 8px;}
    }
  </style>
</head>
<body>
  <div class="bg"></div>
  <div class="wrap">
    <header>
      <div class="bar">
        <div class="title">
          <h1 id="pageTitle">גליל עליון במרכז — כל היריבות מסביב</h1>
          <div class="sub" id="leagueLine">טוען נתונים…</div>
        </div>
        <div class="pill">
          <span id="sourceLine">מקור: GitHub Pages</span>
          <span>•</span>
          <a id="debugLink" href="debug_endpoints.json" target="_blank" rel="noreferrer">debug_endpoints.json</a>
        </div>
      </div>
    </header>

    <main>
      <section class="card">
        <div class="cardHeader">
          <h2>פילטרים</h2>
          <small id="metaSmall">—</small>
        </div>
        <div class="cardBody">
          <div class="row">
            <div>
              <label>בחר מחזור</label>
              <div class="roundRow">
                <button id="roundPrev" class="btnMini" type="button">← מחזור קודם</button>
                <select id="roundSelect"></select>
                <button id="roundNext" class="btnMini" type="button">מחזור הבא →</button>
              </div>
            </div>
            <div>
              <label>הדגש קבוצה (שם חלקי)</label>
              <input id="teamInput" type="text" placeholder="למשל: גליל / חיפה / נהריה" />
            </div>
          </div>

          <div class="row3">
            <div>
              <label>רק משחקים של הקבוצה</label>
              <div style="margin-top:10px; display:flex; gap:10px; align-items:center;">
                <input id="onlyTeam" type="checkbox" style="transform:scale(1.1);" />
                <span class="muted">מסנן את הטבלה והסטטוס</span>
              </div>
            </div>
            <div>
              <label>בחר יריבה במפה</label>
              <div class="muted" style="margin-top:10px;">לחיצה על בועה תסנן</div>
            </div>
            <div>
              <label>איפוס</label>
              <div class="btns" style="margin-top:6px;">
                <button id="resetBtn">אפס פילטרים</button>
              </div>
            </div>
          </div>

          <div class="chips" id="teamChips"></div>

          <div class="btns">
            <button class="primary" id="toggleGames">משחקים</button>
            <button id="toggleStandings">טבלה מלאה</button>
          </div>

          <div class="stats" id="statsBox"></div>
          <div class="err" id="errBox" style="display:none;"></div>

          
        </div>
      </section>

      <section class="map">
        <div class="mapInner card">
          <div class="mapGrid"></div>
          <div class="mapTitle">
            <h2>מפת יריבות</h2>
            <div class="hint">לחץ על קבוצה כדי לראות מפגש אחרון ותוצאות • הקבוצה שלך במרכז</div>
          </div>
          <div id="lines"></div>
          <div id="nodes"></div>
        </div>
      </section>
    
      <section class="card fullSpan" id="tablesCard">
        <div class="cardHeader">
          <h2 id="tablesTitle">טבלאות</h2>
          <small id="tablesHint">התוצאות לפי המסננים</small>
        </div>
        <div class="cardBody">
<div class="twoTables" id="tables">
            <div id="gamesWrap" style="display:block;">
              <div class="muted" style="margin: 6px 0 8px;">משחקים (מחזור / מול היריבה)</div>
              <div style="max-height: 280px; overflow:auto; border-radius:14px;">
                <table id="gamesTable"></table>
              </div>
            </div>
            <div id="standingsWrap" style="display:none;">
              <div class="muted" style="margin: 6px 0 8px;">טבלת הליגה (בלי גלילה)</div>
              <div style="overflow:visible; border-radius:14px;">
                <table id="standingsTable"></table>
              </div>
            </div>
          </div>
        </div>
      </section>
</main>
  </div>

<script>
(() => {
  const DATA_URL = "data.json";
  const state = {
    data: null,
    rounds: [],
    roundOffset: 0,
    selectedRound: null,
    focusTeam: "הפ׳ גליל עליון",
    selectedOpponent: "",
    onlyTeam: false,
    chipTeam: "",
    standings: [],
    standingsMap: new Map(), // normalized name -> row
  };

  const el = (id) => document.getElementById(id);

  const norm = (s)=> (s??"").toString().replace(/\s+/g," ").trim();
  const canon = (s)=> norm(s).toLowerCase()
    .replace(/[\u05F3\u05F4'"`]/g,"")     // ׳ ״ and quotes
    .replace(/[\.\u2019\u2018]/g,"")      // dots & smart quotes
    .replace(/[()\[\]{}]/g," ")
    .replace(/\s+/g," ")
    .trim();
  const low = canon;

// === Robust accessors (names / scores) ===
function homeName(g){
  return norm(g?.homeTeam?.name ?? g?.home?.name ?? g?.homeTeamName ?? g?.home_name ?? g?.homeTeam ?? g?.home ?? "");
}
function awayName(g){
  return norm(g?.awayTeam?.name ?? g?.away?.name ?? g?.awayTeamName ?? g?.away_name ?? g?.awayTeam ?? g?.away ?? "");
}
function homeScore(g){
  return (g?.homeTeam?.score ?? g?.homeScore ?? g?.scoreHome ?? g?.home_team_score ?? g?.score?.home ?? g?.result?.home ?? g?.home?.score ?? null);
}
function awayScore(g){
  return (g?.awayTeam?.score ?? g?.awayScore ?? g?.scoreAway ?? g?.away_team_score ?? g?.score?.away ?? g?.result?.away ?? g?.away?.score ?? null);
}

  function teamEquals(a,b){
    const A = canon(a), B = canon(b);
    if(!A || !B) return false;
    return A===B || A.includes(B) || B.includes(A);
  }

  function extractTeamsFromGames(games){
    const set = new Map();
    for(const g of (games||[])){
      const h = norm(g?.homeTeam?.name || g?.home?.name || g?.home || "");
      const a = norm(g?.awayTeam?.name || g?.away?.name || g?.away || "");
      if(h) set.set(low(h), h);
      if(a) set.set(low(a), a);
    }
    return Array.from(set.values());
  }
function gameHasScore(g){
  const hs = homeScore(g);
  const as = awayScore(g);
  const hsNum = (typeof hs === "number") ? hs : (String(hs ?? "").trim().match(/^\d+$/) ? Number(String(hs).trim()) : null);
  const asNum = (typeof as === "number") ? as : (String(as ?? "").trim().match(/^\d+$/) ? Number(String(as).trim()) : null);
  return (hsNum !== null && asNum !== null);
}

  function gameKeyDate(g){
    const iso = g?.dateISO || g?.datetimeISO || g?.dateTimeISO || g?.dateTime || g?.date;
    if(iso && !isNaN(Date.parse(iso))) return Date.parse(iso);
    const t = g?.dateText || "";
    const m = String(t).match(/(\d{1,2})\.(\d{1,2})\.(\d{2,4}).*?(\d{1,2}):(\d{2})/);
    if(m){
      const dd=+m[1], mm=+m[2], yy=+m[3] + (m[3].length===2 ? 2000 : 0);
      const hh=+m[4], mi=+m[5];
      return Date.parse(`${yy}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')}T${String(hh).padStart(2,'0')}:${String(mi).padStart(2,'0')}:00`);
    }
    return 0;
  }
function gameScoreStr(g){
  if(!gameHasScore(g)) return "";
  const hs = homeScore(g);
  const as = awayScore(g);
  return `${String(hs).trim()} : ${String(as).trim()}`;
}
function lastH2H(teamA, teamB, games){
  if(!teamA || !teamB) return null;
  const relevant = (games||[]).filter(g=>{
    const h = homeName(g), a = awayName(g);
    const ok = ((teamEquals(h, teamA) && teamEquals(a, teamB)) || (teamEquals(h, teamB) && teamEquals(a, teamA)));
    return ok && gameHasScore(g);
  });
  if(!relevant.length) return null;
  relevant.sort((a,b)=> gameKeyDate(b) - gameKeyDate(a));
  return relevant[0];
});
    if(!relevant.length) return null;
    relevant.sort((a,b)=> gameKeyDate(b) - gameKeyDate(a));
    return relevant[0];
  }
function lastGameForTeam(teamName, games){
  if(!teamName) return null;
  const relevant = (games||[]).filter(g=>{
    const h = homeName(g), a = awayName(g);
    return (teamEquals(h, teamName) || teamEquals(a, teamName)) && gameHasScore(g);
  });
  if(!relevant.length) return null;
  relevant.sort((a,b)=> gameKeyDate(b) - gameKeyDate(a));
  return relevant[0];
});
    if(!relevant.length) return null;
    relevant.sort((a,b)=> gameKeyDate(b) - gameKeyDate(a));
    return relevant[0];
  }

  function computeStandingsFromGames(games){
    const rows = new Map(); // key -> stats
    const get = (name)=>{
      const k = low(name);
      if(!rows.has(k)){
        rows.set(k,{name, played:0, w:0, d:0, l:0, gf:0, ga:0, gd:0, points:0});
      }
      return rows.get(k);
    };
    for(const g of (games||[])){
      const home = norm(g?.homeTeam?.name || g?.home?.name || g?.home || "");
      const away = norm(g?.awayTeam?.name || g?.away?.name || g?.away || "");
      if(!home || !away) continue;

      const hs = (g?.homeTeam?.score ?? g?.homeScore ?? g?.scoreHome);
      const as = (g?.awayTeam?.score ?? g?.awayScore ?? g?.scoreAway);

      const hsNum = (typeof hs === "number") ? hs : (String(hs||"").match(/^\d+$/) ? Number(hs) : null);
      const asNum = (typeof as === "number") ? as : (String(as||"").match(/^\d+$/) ? Number(as) : null);
      if(hsNum === null || asNum === null) continue;

      const H = get(home), A = get(away);
      H.played++; A.played++;
      H.gf += hsNum; H.ga += asNum;
      A.gf += asNum; A.ga += hsNum;

      if(hsNum > asNum){ H.w++; A.l++; H.points += 2; }
      else if(hsNum < asNum){ A.w++; H.l++; A.points += 2; }
      else { H.d++; A.d++; H.points += 1; A.points += 1; }
    }
    const arr = Array.from(rows.values()).map(r=>({...r, gd: r.gf - r.ga}));
    arr.sort((a,b)=> (b.points-a.points) || (b.gd-a.gd) || (b.gf-a.gf) || a.name.localeCompare(b.name, "he"));
    arr.forEach((r,i)=>{ r.rank = i+1; r.pts=r.points; });
    return arr;
  }

  function buildStandings(){
    const raw = state.data?.standings;
    let s = Array.isArray(raw) ? raw.slice() : [];
    // normalize common keys
    const normalized = s.map(r => ({
      name: norm(r.name),
      rank: r.rank ?? r.position ?? r.pos ?? "",
      points: r.points ?? r.pts ?? r.point ?? "",
      played: r.played ?? r.games ?? r.gp ?? "",
      w: r.w ?? r.win ?? r.wins ?? "",
      d: r.d ?? r.draw ?? r.draws ?? "",
      l: r.l ?? r.loss ?? r.losses ?? "",
      gf: r.gf ?? r.plus ?? r.for ?? "",
      ga: r.ga ?? r.minus ?? r.against ?? "",
      gd: r.gd ?? r.diff ?? "",
    })).filter(x => x.name);

    const hasPoints = normalized.some(x => String(x.points).match(/^\d+$/));
    const hasRanks = normalized.some(x => String(x.rank).match(/^\d+$/));
    const hasW = normalized.some(x => String(x.w).match(/^\d+$/));

    if(!normalized.length || !hasPoints){
      // fallback from games results
      const comp = computeStandingsFromGames(state.data?.games || []);
      s = comp;
    } else {
      s = normalized;
      // if rank missing, compute sort by points/gd
      if(!hasRanks){
        s = s.map(x => ({...x, points: Number(x.points)||0, gd: Number(x.gd)||0, gf: Number(x.gf)||0}));
        s.sort((a,b)=> (b.points-a.points) || (b.gd-a.gd) || (b.gf-a.gf) || a.name.localeCompare(b.name, "he"));
        s.forEach((r,i)=> r.rank = i+1);
      }
      // If W/L etc missing, try compute from games (but keep points/rank from source)
      if(!hasW){
        const compMap = new Map(computeStandingsFromGames(state.data?.games||[]).map(r => [low(r.name), r]));
        s = s.map(r => {
          const c = compMap.get(low(r.name));
          return c ? {...r, played:c.played, w:c.w, d:c.d, l:c.l, gf:c.gf, ga:c.ga, gd:c.gd} : r;
        });
      }
    }

    // standings map
    state.standings = s;
    state.standingsMap = new Map();
    for(const r of s){
      state.standingsMap.set(low(r.name), r);
    }
  }

  function getStanding(teamName){
    const t = low(teamName);
    if(!t) return null;
    // exact key
    if(state.standingsMap.has(t)) return state.standingsMap.get(t);
    // contains fallback
    for(const [k,v] of state.standingsMap.entries()){
      if(k.includes(t) || t.includes(k)) return v;
    }
    return null;
  }

  function getTeams(){
    const fromStandings = (state.standings||[]).map(x=>x.name).filter(Boolean);
    const fromGames = extractTeamsFromGames(state.data?.games||[]);
    const map = new Map();
    for(const t of [...fromStandings, ...fromGames]){
      map.set(low(t), norm(t));
    }
    return Array.from(map.values());
  }

  function computeRoundOffset(){
    const nums = state.rounds.map(r=>Number(r.number)).filter(n=>Number.isFinite(n));
    if(!nums.length){ state.roundOffset = 0; return; }
    const min = Math.min(...nums);
    state.roundOffset = (min === 0) ? 1 : 0;
  }
  function displayRound(n){
    const num = Number(n);
    return Number.isFinite(num) ? (num + state.roundOffset) : n;
  }
  function formatDateHeb(raw){
    if(!raw) return "";
    return String(raw).replace("T"," ").replace("Z","");
  }

  function scoreText(game){
    const hs = game?.homeTeam?.score;
    const as = game?.awayTeam?.score;
    const hasScore = (hs !== null && hs !== undefined && hs !== "") || (as !== null && as !== undefined && as !== "");
    if(!hasScore) return "—";
    return `${hs ?? ""} - ${as ?? ""}`;
  }

  function leagueLine(){
    const m = state.data?.meta || {};
    const league = state.data?.league?.name || m?.leagueName || "";
    const season = m?.season || "";
    const fetchedAt = m?.fetchedAt || m?.last_update || "";
    const games = (state.data?.games || []).length;
    const rounds = state.rounds.length;
    return `${league} • ${season} • משחקים: ${games} • מחזורים: ${rounds} • עודכן: ${formatDateHeb(fetchedAt)}`;
  }

  function setErr(msg){
    const box = el("errBox");
    if(!msg){ box.style.display="none"; box.textContent=""; return; }
    box.style.display="block"; box.textContent = msg;
  }

  function buildChips(){
    const container = el("teamChips");
    container.innerHTML = "";
    const teams = getTeams();
    const focus = teams.find(t=>teamEquals(t, state.focusTeam)) || state.focusTeam;

    const add = (label, key) => {
      const d = document.createElement("div");
      d.className = "chip" + ((state.chipTeam && teamEquals(state.chipTeam, key)) ? " active" : "");
      d.textContent = label;
      d.onclick = () => {
        state.chipTeam = (state.chipTeam && teamEquals(state.chipTeam, key)) ? "" : key;
        renderAll();
      };
      container.appendChild(d);
    };

    add("הכל", "");
    // focus first
    add(focus, focus);
    teams.filter(t => !teamEquals(t, focus)).slice(0, 20).forEach(t => add(t, t));
  }

  function buildRoundSelect(){
    const sel = el("roundSelect");
    sel.innerHTML = "";
    state.rounds.forEach(r=>{
      const opt = document.createElement("option");
      opt.value = String(r.number);
      opt.textContent = `מחזור ${displayRound(r.number)} (${r.gamesCount})`;
      sel.appendChild(opt);
    });
    if(state.selectedRound === null && state.rounds.length){
      state.selectedRound = String(state.rounds[0].number);
    }
    sel.value = String(state.selectedRound ?? "");
    sel.onchange = ()=>{ state.selectedRound = sel.value; renderAll(); };

    const prevBtn = el("roundPrev");
    const nextBtn = el("roundNext");
    const setDisabled = ()=>{
      const idx = state.rounds.findIndex(r=> String(r.number)===String(state.selectedRound));
      prevBtn.disabled = idx<=0;
      nextBtn.disabled = idx<0 || idx>=state.rounds.length-1;
    };
    const go = (delta)=>{
      const idx = state.rounds.findIndex(r=> String(r.number)===String(state.selectedRound));
      if(idx<0) return;
      const ni = Math.max(0, Math.min(state.rounds.length-1, idx+delta));
      state.selectedRound = String(state.rounds[ni].number);
      sel.value = state.selectedRound;
      renderAll();
      setDisabled();
    };
    prevBtn.onclick = ()=>go(-1);
    nextBtn.onclick = ()=>go(1);
    setDisabled();
  }
function isTeamInGame(game, team){
  const t = norm(team);
  const home = homeName(game);
  const away = awayName(game);
  return teamEquals(home,t) || teamEquals(away,t) || home.includes(t) || away.includes(t) || t.includes(home) || t.includes(away);
}

  function filteredGames(){
    const games = state.data?.games || [];
    const focus = state.focusTeam;
    const opp = state.selectedOpponent;
    const chip = state.chipTeam;
    const onlyTeam = !!state.onlyTeam;
    const q = canon(el("teamInput").value);

    let g = [];
    if (opp){
      // כשבחרו יריבה – מציגים את כל המפגשים מול היריבה (כל המחזורים)
      g = games.filter(x => isTeamInGame(x, focus) && isTeamInGame(x, opp));
    } else {
      const round = state.selectedRound;
      g = games.filter(x => String(x?.round?.number) === String(round));
    }

    if (onlyTeam) g = g.filter(x => isTeamInGame(x, focus));
    if (chip) g = g.filter(x => isTeamInGame(x, chip));

    if (q){
      g = g.filter(x => canon(x?.homeTeam?.name).includes(q) || canon(x?.awayTeam?.name).includes(q));
    }

    g.sort((a,b)=> (gameKeyDate(a)||0) - (gameKeyDate(b)||0));
    return g;
  }

  function renderGamesTable(){
    const tbl = el("gamesTable");
    const g = filteredGames();
    const rows = [];
    rows.push(`<thead><tr>
      <th>תאריך</th><th>בית</th><th>תוצאה</th><th>חוץ</th><th>מיקום</th>
    </tr></thead>`);
    rows.push("<tbody>");
    if(!g.length){ rows.push(`<tr><td colspan="5" style="text-align:center; color: rgba(255,255,255,.70); padding: 14px 10px;">אין משחקים לתצוגה לפי הסינון הנוכחי</td></tr>`); }
    for(const game of g){
      const date = game?.date ? formatDateHeb(game.date) : (game?.dateText || "");
      const home = norm(game?.homeTeam?.name);
      const away = norm(game?.awayTeam?.name);
      const loc = norm(game?.field?.name || game?.location || "");
      rows.push(`<tr>
        <td>${date}</td>
        <td>${home}</td>
        <td><b>${scoreText(game)}</b></td>
        <td>${away}</td>
        <td class="muted">${loc}</td>
      </tr>`);
    }
    rows.push("</tbody>");
    tbl.innerHTML = rows.join("");
  }

  function renderStandingsTable(){
    const tbl = el("standingsTable");
    const s = state.standings || [];
    const focus = state.focusTeam;

    const rows = [];
    rows.push(`<thead><tr>
      <th>#</th><th>קבוצה</th><th>נק'</th><th>מש</th><th>נ</th><th>ה</th><th>ת</th><th>+</th><th>-</th><th>הפרש</th>
    </tr></thead>`);
    rows.push("<tbody>");
    for(const r of s){
      const name = norm(r.name);
      const isFocus = teamEquals(name, focus);
      rows.push(`<tr style="${isFocus ? 'background: rgba(58,167,255,.10);' : ''}">
        <td>${r.rank ?? ""}</td>
        <td><b>${name}</b></td>
        <td><b>${r.points ?? r.pts ?? ""}</b></td>
        <td>${r.played ?? r.games ?? ""}</td>
        <td>${r.w ?? ""}</td>
        <td>${r.l ?? ""}</td>
        <td>${r.d ?? ""}</td>
        <td>${r.gf ?? ""}</td>
        <td>${r.ga ?? ""}</td>
        <td>${r.gd ?? ""}</td>
      </tr>`);
    }
    rows.push("</tbody>");
    tbl.innerHTML = rows.join("");
  }

  function renderStats(){
    const box = el("statsBox");
    const focus = state.focusTeam;
    const opp = state.selectedOpponent;
    const round = displayRound(state.selectedRound ?? "");
    const g = filteredGames();
    const total = g.length;

    const last = lastGameForTeam(focus, state.data?.games || []);
    const lastOpp = opp ? lastH2H(focus, opp, state.data?.games || []) : null;

    const lastLine = last
      ? `משחק אחרון: <b>${(teamEquals(last.homeTeam?.name, focus) ? last.awayTeam?.name : last.homeTeam?.name)}</b> — <b>${gameScoreStr(last)}</b>${last.dateText ? ` <span class="muted">(${last.dateText})</span>` : ""}`
      : `משחק אחרון: <span class="muted">אין תוצאה קודמת</span>`;

    const lastOppLine = opp
      ? (lastOpp
          ? `מפגש אחרון מול <b>${opp}</b>: <b>${gameScoreStr(lastOpp)}</b>${lastOpp.dateText ? ` <span class="muted">(${lastOpp.dateText})</span>` : ""}`
          : `מפגש אחרון מול <b>${opp}</b>: <span class="muted">אין תוצאה</span>`)
      : `מפגש אחרון מול יריבה: <span class="muted">לא נבחרה</span>`;

    const st = getStanding(focus);
    const stLine = st
      ? `מיקום בטבלה: <b>${st.rank ?? "—"}</b> • נק': <b>${st.points ?? st.pts ?? "—"}</b> • מאזן: <b>${st.w ?? "—"}-${st.l ?? "—"}</b> • הפרש: <b>${st.gd ?? "—"}</b>`
      : `מיקום בטבלה: <span class="muted">אין נתונים</span>`;

    box.innerHTML = [
      `קבוצה במרכז: <b>${focus}</b>`,
      opp ? `יריבה נבחרת: <b>${opp}</b>` : `יריבה נבחרת: <span class="muted">לא נבחרה</span>`,
      stLine,
      `מחזור: <b>${round}</b> • משחקים מוצגים: <b>${total}</b>`,
      lastLine,
      lastOppLine,
    ].join("<br/>");
  }

  function renderMap(){
    const nodesEl = el("nodes");
    const linesEl = el("lines");
    nodesEl.innerHTML = "";
    linesEl.innerHTML = "";

    const teams = getTeams();
    if(!teams.length) return;

    // determine focus exact in list (so no empty)
    const focus = teams.find(t=>teamEquals(t, state.focusTeam)) || state.focusTeam;

    // Center: only in the middle (no duplicate elsewhere)
    const center = document.createElement("div");
    center.className = "node center";
    center.style.left = "50%";
    center.style.top = "55%";
    const focusStanding = getStanding(focus);
    const pts = focusStanding?.points ?? focusStanding?.pts ?? "—";
    const rank = focusStanding?.rank ?? "—";
    const wl = (focusStanding?.w !== undefined && focusStanding?.l !== undefined)
      ? `${focusStanding.w}-${focusStanding.l}` : "—";
    const gd = focusStanding?.gd ?? "—";

    center.innerHTML = `<div class="name">${focus}</div>
      <div class="meta"><span>מקום ${rank}</span><span>${pts} נק׳</span></div>
      <div class="meta2">מאזן ${wl} • הפרש ${gd}</div>
      <div class="cta">הקבוצה שלנו (לחיצה לאיפוס יריבה)</div>`;
    center.onclick = ()=>{ state.selectedOpponent = ""; renderAll(); };
    nodesEl.appendChild(center);

    const others = teams.filter(t => !teamEquals(t, focus));
    const count = others.length;
    const radiusX = 320;
    const radiusY = 240;
    const cx = 0.5, cy = 0.55;

    const getPos = (i) => {
      const a = (i / Math.max(1,count)) * Math.PI * 2;
      const x = cx + (Math.cos(a) * radiusX) / 1000;
      const y = cy + (Math.sin(a) * radiusY) / 720;
      return {x, y};
    };

    others.forEach((team, i) => {
      const p = getPos(i);
      const left = (p.x * 100) + "%";
      const top = (p.y * 100) + "%";
      const st = getStanding(team);
      const lastOpp = lastH2H(focus, team, state.data?.games || []);
      const lastOppLine = lastOpp
        ? `מפגש אחרון: ${gameScoreStr(lastOpp)}${lastOpp.dateText ? ` <span class="muted">(${lastOpp.dateText})</span>` : ""}`
        : `מפגש אחרון: <span class="muted">אין תוצאה</span>`;

      const line = document.createElement("div");
      line.className = "line";
      line.dataset.to = JSON.stringify({x:left,y:top});
      linesEl.appendChild(line);

      const d = document.createElement("div");
      d.className = "node";
      d.style.left = left;
      d.style.top = top;
      d.innerHTML = `<div class="name">${team}</div>
        <div class="meta"><span>מקום ${st?.rank ?? "—"}</span><span>${st?.points ?? st?.pts ?? "—"} נק׳</span></div>
        <div class="meta2">${lastOppLine}</div>
        <div class="cta">לחץ לצפייה</div>`;
      d.onclick = ()=>{ state.selectedOpponent = team; renderAll(); };
      nodesEl.appendChild(d);
    });

    requestAnimationFrame(() => {
      const map = document.querySelector(".mapInner");
      const rect = map.getBoundingClientRect();
      const centerX = rect.width * 0.5;
      const centerY = rect.height * 0.55;
      for(const line of linesEl.querySelectorAll(".line")){
        const to = JSON.parse(line.dataset.to);
        const xPct = parseFloat(String(to.x).replace("%",""))/100;
        const yPct = parseFloat(String(to.y).replace("%",""))/100;
        const x2 = rect.width * xPct;
        const y2 = rect.height * yPct;
        const dx = x2 - centerX;
        const dy = y2 - centerY;
        const len = Math.sqrt(dx*dx + dy*dy);
        const ang = Math.atan2(dy, dx);
        line.style.left = centerX + "px";
        line.style.top = centerY + "px";
        line.style.width = len + "px";
        line.style.transform = `rotate(${ang}rad)`;
      }
    });
  }

  function renderAll(){
    state.onlyTeam = el("onlyTeam").checked;

    renderStats();
    renderGamesTable();
    renderStandingsTable();
    renderMap();
    buildChips();

    // כותרת טבלאות + ניווט
    const tTitle = el("tablesTitle");
    const tHint = el("tablesHint");
    if (tTitle && tHint){
      if (state.selectedOpponent){
        tTitle.textContent = `משחקים מול ${state.selectedOpponent}`;
        tHint.textContent = `כל המפגשים בין ${state.focusTeam} ל-${state.selectedOpponent} (כל המחזורים)`;
        // כשנבחרה יריבה – נציג כברירת מחדל את משחקים
        el("gamesWrap").style.display = "block";
        el("standingsWrap").style.display = "none";
      } else {
        tTitle.textContent = `מחזור ${displayRound(state.selectedRound ?? "")} — משחקים`;
        tHint.textContent = "משחקים במחזור הנבחר";
      }
    }
    const tablesCard = el("tablesCard");
    if (tablesCard) tablesCard.style.display = "block";

    const m = state.data?.meta || {};
    const ver = m?.version ? `v${m.version}` : "";
    const fetched = m?.fetchedAt || m?.last_update || "";
    el("metaSmall").textContent = `${ver}${fetched ? " • " + formatDateHeb(fetched) : ""}`;
  }

  function setupToggles(){
    el("toggleGames").onclick = ()=>{ el("gamesWrap").style.display="block"; el("standingsWrap").style.display="none"; };
    el("toggleStandings").onclick = ()=>{ el("gamesWrap").style.display="none"; el("standingsWrap").style.display="block"; };
    el("resetBtn").onclick = ()=>{
      state.selectedOpponent = "";
      state.chipTeam = "";
      el("teamInput").value = "";
      el("onlyTeam").checked = false;
      renderAll();
    };
    el("teamInput").addEventListener("input", ()=>renderAll());
    el("onlyTeam").addEventListener("change", ()=>renderAll());
  }

  async function load(){
    setupToggles();
    try{
      const res = await fetch(DATA_URL, { cache: "no-store" });
      if(!res.ok) throw new Error("HTTP " + res.status);
      state.data = await res.json();

      // build standings + teams fallback
      buildStandings();

      // rounds from meta.roundsFetched OR derive from games
      const metaRounds = state.data?.meta?.roundsFetched;
      if(Array.isArray(metaRounds) && metaRounds.length){
        state.rounds = metaRounds.map(r=>({ number:String(r.number), gamesCount:Number(r.gamesCount||0) }));
      } else {
        const by = new Map();
        for(const g of (state.data?.games||[])){
          const n = String(g?.round?.number ?? "");
          if(!n) continue;
          by.set(n, (by.get(n)||0) + 1);
        }
        state.rounds = Array.from(by.entries()).map(([number,gamesCount])=>({number, gamesCount}))
          .sort((a,b)=> Number(a.number) - Number(b.number));
      }
      computeRoundOffset();
      buildRoundSelect();

      el("leagueLine").innerHTML = leagueLine();
      renderAll();
      setErr("");
    } catch(e){
      console.error(e);
      setErr("לא הצלחתי לטעון את data.json. אם אתה פותח דרך file:// זה לא יעבוד — פתח דרך Live Server או GitHub Pages.\nשגיאה: " + (e?.message||e));
      el("leagueLine").textContent = "שגיאה בטעינה";
    }
  }

  load();
})();
</script>
</body>
</html>
