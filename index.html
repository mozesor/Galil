<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>גליל – לוח יריבות (מפה)</title>
  <style>
    :root{
      --bg0:#040812; --bg1:#071427;
      --glass: rgba(18,30,48,.55);
      --glass2: rgba(18,30,48,.38);
      --stroke: rgba(255,255,255,.10);
      --stroke2: rgba(58,167,255,.22);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --muted2: rgba(255,255,255,.55);
      --accent:#3aa7ff; --accent2:#79d2ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text);
      font-family: system-ui,-apple-system,"Segoe UI",Arial,"Noto Sans Hebrew",sans-serif;
      background:
        radial-gradient(1200px 600px at 70% 20%, rgba(58,167,255,.16), transparent 55%),
        radial-gradient(900px 500px at 20% 15%, rgba(121,210,255,.10), transparent 50%),
        linear-gradient(180deg,var(--bg1),var(--bg0));
      overflow-x:hidden;
    }
    .bg{
      position:fixed; inset:0; pointer-events:none;
      background: url("assets/bg-tree.svg") center/cover no-repeat;
      opacity:.30;
    }
    .bg::after{
      content:""; position:absolute; inset:0;
      background: radial-gradient(900px 600px at 50% 40%, rgba(0,0,0,.10), rgba(0,0,0,.65));
    }
    .wrap{position:relative; min-height:100%}
    header{
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(10px);
      background: linear-gradient(90deg, rgba(10,18,32,.55), rgba(10,18,32,.35));
      border-bottom:1px solid var(--stroke);
    }
    .bar{
      max-width:1320px; margin:0 auto;
      padding:14px 18px;
      display:flex; gap:14px;
      align-items:center; justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{display:flex; flex-direction:column; gap:4px; min-width:260px}
    .title h1{margin:0; font-size:22px; letter-spacing:.2px}
    .title .sub{color:var(--muted); font-size:13px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.03);
      border-radius:999px;
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .pill a{color:var(--accent2); text-decoration:none}
    .pill a:hover{text-decoration:underline}

    main{
      max-width:1320px;
      margin:16px auto 26px;
      padding:0 14px;
      display:grid;
      grid-template-columns: 420px 1fr;
      grid-template-areas:
        "filters map"
        "tables tables";
      gap:16px;
    }

    .card{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg,var(--glass), rgba(7,15,26,.35));
      border-radius:18px;
      box-shadow:0 20px 70px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .cardHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--stroke);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .cardHeader h2{margin:0; font-size:16px}
    .cardHeader small{color:var(--muted2); font-size:12px}
    .cardBody{padding:12px 14px 14px}

    label{font-size:13px; color:var(--muted)}
    input[type="text"], select{
      width:100%;
      margin-top:6px;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.03);
      color:var(--text);
      outline:none;
    }
    input::placeholder{color: rgba(255,255,255,.45)}
    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px}
    .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin-top:10px}

    /* Windows dropdown fix */
    select, option{ background-color: rgba(8,22,38,.98); color:var(--text); }
    select:focus{ outline:2px solid rgba(94,212,255,.55); outline-offset:2px; }

    .chips{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px}
    .chip{
      cursor:pointer; user-select:none;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
      transition:.15s ease;
    }
    .chip:hover{border-color:var(--stroke2); color:var(--text)}
    .chip.active{
      border-color: rgba(58,167,255,.55);
      background: rgba(58,167,255,.12);
      color: var(--text);
      box-shadow: 0 0 0 3px rgba(58,167,255,.10) inset;
    }

    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px}
    button{
      cursor:pointer;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:600;
      transition:.15s ease;
    }
    button:hover{border-color:var(--stroke2); background: rgba(58,167,255,.10)}
    button.primary{border-color: rgba(58,167,255,.55); background: rgba(58,167,255,.12)}
    button:disabled{opacity:.45; cursor:not-allowed}

    .roundRow{display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap}
    .roundRow .btnMini{
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(18,45,72,.55);
      color:var(--text);
    }
    .roundRow .btnMini:hover{background: rgba(18,45,72,.75)}

    .stats{
      margin-top:12px;
      padding:10px 12px;
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.14);
      background: rgba(0,0,0,.15);
      color: var(--muted);
      font-size:12px;
      line-height:1.6;
    }

    .err{
      margin-top:10px;
      padding:10px 12px;
      border:1px solid rgba(251,191,36,.35);
      border-radius:14px;
      background: rgba(251,191,36,.08);
      color: rgba(255,255,255,.90);
      font-size:12px;
      line-height:1.5;
      white-space:pre-wrap;
    }
    .warn{
      margin-top:10px;
      padding:10px 12px;
      border:1px solid rgba(58,167,255,.35);
      border-radius:14px;
      background: rgba(58,167,255,.08);
      color: rgba(255,255,255,.90);
      font-size:12px;
      line-height:1.5;
      white-space:pre-wrap;
    }

    /* Map */
    .filters{grid-area:filters}
    .map{grid-area:map; position:relative; min-height:720px}
    .mapInner{
      position:relative; height:720px;
      border-radius:18px; overflow:hidden;
      border:1px solid var(--stroke);
      background: radial-gradient(700px 420px at 50% 50%, rgba(58,167,255,.10), rgba(0,0,0,.15));
    }
    .mapGrid{
      position:absolute; inset:0;
      background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,.07) 1px, transparent 0);
      background-size:22px 22px;
      opacity:.25;
    }
    .mapTitle{
      position:absolute; top:14px; right:14px; left:14px;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    .mapTitle h2{margin:0; font-size:18px}
    .mapTitle .hint{color:var(--muted2); font-size:12px; text-align:left}

    .node{
      position:absolute;
      width: 210px;
      transform: translate(-50%,-50%);
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(15,26,42,.75), rgba(9,16,27,.55));
      box-shadow: 0 16px 44px rgba(0,0,0,.35);
      padding: 12px 12px 10px;
      cursor:pointer;
      transition:.16s ease;
    }
    .node:hover{border-color: rgba(58,167,255,.50); box-shadow:0 18px 52px rgba(0,0,0,.42)}
    .node .name{font-weight:800; font-size:14px; line-height:1.2; margin-bottom:6px}
    .node .meta{color:var(--muted2); font-size:12px; display:flex; justify-content:space-between; gap:10px}
    .node .meta2{font-size:12px; opacity:.92; margin-top:6px; color: rgba(210,240,255,.92)}
    .node .cta{margin-top:8px; color:var(--accent2); font-size:12px}
    .node.center{
      width: 270px;
      border-color: rgba(58,167,255,.55);
      background: linear-gradient(180deg, rgba(35,86,120,.70), rgba(10,18,32,.55));
      box-shadow: 0 26px 80px rgba(58,167,255,.10), 0 18px 64px rgba(0,0,0,.45);
    }
    .node.center .name{font-size:16px}

    .line{
      position:absolute; height:1px;
      background: rgba(58,167,255,.16);
      transform-origin: 0 50%;
      pointer-events:none;
    }

    /* Tables (full width) */
    .tables{grid-area:tables}
    .tables .cardBody{padding-top:10px}
    .tablesTop{
      display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap;
    }
    .tablesHint{color:var(--muted2); font-size:12px; margin-top:6px}
    .tableWrap{
      margin-top:10px;
      overflow-x:auto;
      border-radius:14px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.12);
    }
    table{width:100%; border-collapse:collapse; min-width: 820px}
    th,td{padding:12px 12px; font-size:14px; border-bottom:1px solid rgba(255,255,255,.06); vertical-align:middle; white-space:nowrap}
    th{ text-align:right; color: rgba(255,255,255,.85); background: rgba(255,255,255,.04); position:sticky; top:0; z-index:1 }
    tr:hover td{ background: rgba(58,167,255,.06) }
    .muted{color:var(--muted2)}
    .kbd{font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.18); color: rgba(255,255,255,.80)}
    .focusRow td{background: rgba(58,167,255,.10)}

    @media (max-width:1100px){
      main{
        grid-template-columns:1fr;
        grid-template-areas:
          "filters"
          "map"
          "tables";
      }
      .mapInner{height:640px}
      .map{min-height:640px}
      table{min-width: 760px}
    }
    @media (max-width:560px){
      .node{width:180px}
      .node.center{width:220px}
      .row{grid-template-columns:1fr}
      .row3{grid-template-columns:1fr}
      th,td{font-size:13px; padding:10px 10px}
      table{min-width: 720px}
    }
  </style>
</head>
<body>
  <div class="bg"></div>
  <div class="wrap">
    <header>
      <div class="bar">
        <div class="title">
          <h1 id="pageTitle">גליל עליון במרכז — כל היריבות מסביב</h1>
          <div class="sub" id="leagueLine">טוען נתונים…</div>
        </div>
        <div class="pill">
          <span id="sourceLine">מקור: GitHub Pages</span>
          <span>•</span>
          <a id="debugLink" href="debug_endpoints.json" target="_blank" rel="noreferrer">debug_endpoints.json</a>
        </div>
      </div>
    </header>

    <main>
      <section class="card filters">
        <div class="cardHeader">
          <h2>פילטרים</h2>
          <small id="metaSmall">—</small>
        </div>
        <div class="cardBody">
          <div class="row">
            <div>
              <label>בחר מחזור</label>
              <div class="roundRow">
                <button id="roundPrev" class="btnMini" type="button">← מחזור קודם</button>
                <select id="roundSelect"></select>
                <button id="roundNext" class="btnMini" type="button">מחזור הבא →</button>
              </div>
            </div>
            <div>
              <label>הדגש קבוצה (שם חלקי)</label>
              <input id="teamInput" type="text" placeholder="למשל: גליל / חיפה / נהריה" />
            </div>
          </div>

          <div class="row3">
            <div>
              <label>רק משחקים של גליל</label>
              <div style="margin-top:10px; display:flex; gap:10px; align-items:center;">
                <input id="onlyTeam" type="checkbox" style="transform:scale(1.1);" />
                <span class="muted">מסנן את הטבלאות</span>
              </div>
            </div>
            <div>
              <label>בחר יריבה במפה / בצ'יפים</label>
              <div class="muted" style="margin-top:10px;">לחיצה על בועה או צ'יפ תסנן</div>
            </div>
            <div>
              <label>איפוס</label>
              <div class="btns" style="margin-top:6px;">
                <button id="resetBtn">אפס פילטרים</button>
              </div>
            </div>
          </div>

          <div class="chips" id="teamChips"></div>

          <div class="stats" id="statsBox"></div>
          <div class="warn" id="warnBox" style="display:none;"></div>
          <div class="err" id="errBox" style="display:none;"></div>
        </div>
      </section>

      <section class="map">
        <div class="mapInner card">
          <div class="mapGrid"></div>
          <div class="mapTitle">
            <h2>מפת יריבות</h2>
            <div class="hint">לחץ על קבוצה כדי לראות מפגש אחרון + משחקים ביניהם</div>
          </div>
          <div id="lines"></div>
          <div id="nodes"></div>
        </div>
      </section>

      <section class="card tables">
        <div class="cardHeader">
          <h2>טבלאות</h2>
          <small class="muted">הטבלאות תמיד נפרסות על כל הרוחב</small>
        </div>
        <div class="cardBody">
          <div class="tablesTop">
            <button class="primary" id="toggleGames" type="button">משחקים</button>
            <button id="toggleStandings" type="button">טבלה מלאה</button>
          </div>
          <div class="tablesHint" id="tablesHint">—</div>

          <div id="gamesWrap">
            <div class="tableWrap"><table id="gamesTable"></table></div>
          </div>

          <div id="standingsWrap" style="display:none;">
            <div class="tableWrap"><table id="standingsTable"></table></div>
          </div>
        </div>
      </section>
    </main>
  </div>

<script>
(() => {
  // If data.json is missing (rare), we fallback to data.sample.json so the page isn't blank.
  const PRIMARY_DATA_URL = "data.json";
  const FALLBACK_DATA_URL = "data.sample.json";

  const state = {
    data: null,
    rounds: [],
    roundOffset: 0,
    selectedRound: null,
    focusTeamWanted: "גליל עליון", // fuzzy search
    focusTeam: "",                // resolved actual team name
    selectedOpponent: "",
    onlyTeam: true,
    chipTeam: "",
  };

  const el = (id) => document.getElementById(id);

  // ---------- utils ----------
  const PUNCT_RE = /[״"׳'`~!@#$%^&*()\-_=+[\]{};:,.<>/?\\|]/g;

  function norm(s){
    return (s ?? "").toString().trim().replace(/\s+/g," ");
  }
  function canon(s){
    return norm(s)
      .replace(PUNCT_RE, "")
      .replace(/\u200f|\u200e/g, "")
      .toLowerCase();
  }
  function matchTeam(a,b){
    const A = canon(a), B = canon(b);
    if(!A || !B) return false;
    if(A === B) return true;
    return A.includes(B) || B.includes(A);
  }
  function safeArr(v){ return Array.isArray(v) ? v : []; }

  function getMeta(){
    const d = state.data || {};
    // support old schema (root) and new schema (meta)
    const meta = d.meta || {};
    return {
      leagueName: d.league?.name || meta.leagueName || d.leagueName || "",
      season: meta.season || d.season || "",
      fetchedAt: meta.fetchedAt || meta.last_update || d.fetchedAt || d.last_update || "",
      version: meta.version || d.version || "",
    };
  }

  function getStandings(){
    const d = state.data || {};
    return safeArr(d.standings || d.standingsSource || d.table || d.leagueTable);
  }

  function getGames(){
    const d = state.data || {};
    return safeArr(d.games || d.matches || d.schedule || d.fixtures || d.results);
  }

  function resolveFocusTeam(){
    const standings = getStandings();
    const wanted = state.focusTeamWanted;
    const byContains = standings.find(r => matchTeam(r?.name, wanted));
    if(byContains?.name) return norm(byContains.name);

    // fallback: any team containing "גליל"
    const byGalil = standings.find(r => matchTeam(r?.name, "גליל"));
    if(byGalil?.name) return norm(byGalil.name);

    // last resort
    return norm(standings[0]?.name || wanted);
  }

  function uniqueTeams(){
    const teams = getStandings().map(r => norm(r?.name)).filter(Boolean);
    const seen = new Set();
    const out = [];
    for(const t of teams){
      const k = canon(t);
      if(!k || seen.has(k)) continue;
      seen.add(k);
      out.push(t);
    }
    return out;
  }

  function computeRoundOffset(){
    const nums = state.rounds.map(r => Number(r.number)).filter(n => Number.isFinite(n));
    if(!nums.length){ state.roundOffset = 0; return; }
    const min = Math.min(...nums);
    state.roundOffset = (min === 0) ? 1 : 0;
  }
  function displayRound(n){
    const num = Number(n);
    return Number.isFinite(num) ? (num + state.roundOffset) : n;
  }

  function parseDateMs(raw){
    if(!raw) return 0;
    const s = String(raw);

    // ISO-ish
    const tryIso = s.includes("T") ? s : s.replace(" ", "T");
    const isoMs = Date.parse(tryIso);
    if(!Number.isNaN(isoMs)) return isoMs;

    // dd.mm.yyyy hh:mm
    const m = s.match(/(\d{1,2})\.(\d{1,2})\.(\d{2,4}).*?(\d{1,2}):(\d{2})/);
    if(m){
      const dd=+m[1], mm=+m[2], yy=+m[3] + (m[3].length===2 ? 2000 : 0);
      const hh=+m[4], mi=+m[5];
      const ms = Date.parse(`${yy}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')}T${String(hh).padStart(2,'0')}:${String(mi).padStart(2,'0')}:00`);
      if(!Number.isNaN(ms)) return ms;
    }
    return 0;
  }

  function formatDateHeb(game){
    // accepts game object or raw string
    const raw = typeof game === "string" ? game : (
      game?.dateISO || game?.datetimeISO || game?.dateTimeISO || game?.dateTime || game?.date || game?.dateText || ""
    );
    const ms = parseDateMs(raw);
    if(ms){
      const dt = new Date(ms);
      // he-IL gives RTL-friendly ordering; keep 24h
      const d = new Intl.DateTimeFormat("he-IL", { day:"2-digit", month:"2-digit", year:"numeric" }).format(dt);
      const t = new Intl.DateTimeFormat("he-IL", { hour:"2-digit", minute:"2-digit", hour12:false }).format(dt);
      return `${t} ${d}`; // time then date (matches your screenshots)
    }
    // fallback: clean string
    return String(raw).replace("T"," ").replace(".000","").replace("Z","").trim();
  }

  function scoreNums(game){
    const hs = (game?.homeTeam?.score ?? game?.homeScore ?? game?.scoreHome ?? game?.home?.score ?? game?.score?.home);
    const as = (game?.awayTeam?.score ?? game?.awayScore ?? game?.scoreAway ?? game?.away?.score ?? game?.score?.away);
    const hsNum = (typeof hs === "number") ? hs : (String(hs ?? "").match(/^\d+$/) ? Number(hs) : null);
    const asNum = (typeof as === "number") ? as : (String(as ?? "").match(/^\d+$/) ? Number(as) : null);
    return {hsNum, asNum};
  }

  function hasScore(game){
    const {hsNum, asNum} = scoreNums(game);
    return hsNum !== null && asNum !== null;
  }

  function scoreText(game){
    const {hsNum, asNum} = scoreNums(game);
    if(hsNum === null || asNum === null) return "—";
    return `${hsNum} - ${asNum}`;
  }

  function teamNameFromGame(game, side){
    // try multiple schemas
    if(side === "home") return norm(game?.homeTeam?.name || game?.home?.name || game?.homeTeamName || game?.home || "");
    return norm(game?.awayTeam?.name || game?.away?.name || game?.awayTeamName || game?.away || "");
  }

  function isTeamInGame(game, team){
    const t = norm(team);
    const home = teamNameFromGame(game, "home");
    const away = teamNameFromGame(game, "away");
    return matchTeam(home, t) || matchTeam(away, t);
  }

  function opponentOf(game, team){
    const t = norm(team);
    const home = teamNameFromGame(game,"home");
    const away = teamNameFromGame(game,"away");
    if(matchTeam(home, t)) return away;
    if(matchTeam(away, t)) return home;
    return "";
  }

  function gamesBetween(teamA, teamB, games){
    const A = norm(teamA), B = norm(teamB);
    return (games || []).filter(g => isTeamInGame(g, A) && isTeamInGame(g, B));
  }

  function lastGameBetween(teamA, teamB, games){
    const arr = gamesBetween(teamA, teamB, games).filter(hasScore);
    if(!arr.length) return null;
    arr.sort((a,b) => parseDateMs(b?.dateISO || b?.dateTime || b?.date || b?.dateText) - parseDateMs(a?.dateISO || a?.dateTime || a?.date || a?.dateText));
    return arr[0];
  }

  function lastGameForTeam(team, games){
    const arr = (games || []).filter(g => isTeamInGame(g, team) && hasScore(g));
    if(!arr.length) return null;
    arr.sort((a,b) => parseDateMs(b?.dateISO || b?.dateTime || b?.date || b?.dateText) - parseDateMs(a?.dateISO || a?.dateTime || a?.date || a?.dateText));
    return arr[0];
  }

  // ---------- UI builders ----------
  function setErr(msg){
    const box = el("errBox");
    if(!msg){ box.style.display="none"; box.textContent=""; return; }
    box.style.display="block";
    box.textContent = msg;
  }
  function setWarn(msg){
    const box = el("warnBox");
    if(!msg){ box.style.display="none"; box.textContent=""; return; }
    box.style.display="block";
    box.textContent = msg;
  }

  function leagueLine(){
    const m = getMeta();
    const games = getGames().length;
    const rounds = state.rounds.length;
    const pieces = [
      m.leagueName || "ליגה",
      m.season || "",
      `משחקים: ${games}`,
      `מחזורים: ${rounds}`,
      m.fetchedAt ? `עודכן: ${m.fetchedAt}` : ""
    ].filter(Boolean);
    return pieces.join(" • ");
  }

  function buildChips(){
    const container = el("teamChips");
    container.innerHTML = "";
    const teams = uniqueTeams();
    const focus = state.focusTeam;

    const add = (label, key) => {
      const d = document.createElement("div");
      d.className = "chip" + ((state.chipTeam && matchTeam(state.chipTeam, key)) ? " active" : "");
      d.textContent = label;
      d.onclick = () => {
        // toggle
        if(state.chipTeam && matchTeam(state.chipTeam, key)) state.chipTeam = "";
        else state.chipTeam = key;

        // selecting a chip = selecting opponent (except focus itself)
        if(key && !matchTeam(key, focus)) state.selectedOpponent = key;
        else state.selectedOpponent = "";

        renderAll();
      };
      container.appendChild(d);
    };

    add("הכל", "");
    if(focus) add(focus, focus);
    teams.filter(t => focus ? !matchTeam(t, focus) : true).slice(0, 24).forEach(t => add(t, t));
  }

  function buildRoundSelect(){
    const sel = el("roundSelect");
    sel.innerHTML = "";
    for(const r of state.rounds){
      const opt = document.createElement("option");
      opt.value = String(r.number);
      opt.textContent = `מחזור ${displayRound(r.number)} (${r.gamesCount})`;
      sel.appendChild(opt);
    }

    if(state.selectedRound === null && state.rounds.length){
      // default: first round in list
      state.selectedRound = String(state.rounds[0].number);
    }
    sel.value = String(state.selectedRound ?? "");
    sel.onchange = () => { state.selectedRound = sel.value; renderAll(); };

    const prevBtn = el("roundPrev");
    const nextBtn = el("roundNext");

    const setDisabled = () => {
      const idx = state.rounds.findIndex(r => String(r.number) === String(state.selectedRound));
      prevBtn.disabled = idx <= 0;
      nextBtn.disabled = idx < 0 || idx >= state.rounds.length - 1;
    };

    const go = (delta) => {
      const idx = state.rounds.findIndex(r => String(r.number) === String(state.selectedRound));
      if(idx < 0) return;
      const ni = Math.max(0, Math.min(state.rounds.length - 1, idx + delta));
      state.selectedRound = String(state.rounds[ni].number);
      sel.value = state.selectedRound;
      renderAll();
      setDisabled();
    };

    prevBtn.onclick = () => go(-1);
    nextBtn.onclick = () => go(1);
    setDisabled();
  }

  // ---------- filtering ----------
  function filteredGames(){
    const games = getGames();
    const focus = state.focusTeam;
    const opp = state.selectedOpponent ? norm(state.selectedOpponent) : "";
    const chip = state.chipTeam ? norm(state.chipTeam) : "";
    const onlyTeam = !!state.onlyTeam;
    const round = state.selectedRound;

    let g = games.slice();

    // round filter (if we have round info)
    if(round !== null && round !== "" && g.some(x => x?.round?.number !== undefined)){
      g = g.filter(x => String(x?.round?.number) === String(round));
    }

    // if opponent selected -> show only head-to-head vs focus
    if(opp){
      g = g.filter(x => isTeamInGame(x, focus) && isTeamInGame(x, opp));
    } else {
      if(onlyTeam) g = g.filter(x => isTeamInGame(x, focus));
      if(chip && !matchTeam(chip, focus)) g = g.filter(x => isTeamInGame(x, chip));
    }

    // search box (partial)
    const q = norm(el("teamInput").value);
    if(q){
      const ql = canon(q);
      g = g.filter(x => canon(teamNameFromGame(x,"home")).includes(ql) || canon(teamNameFromGame(x,"away")).includes(ql));
    }

    // sort by date/time if possible
    g.sort((a,b) => (parseDateMs(a?.dateISO || a?.dateTime || a?.date || a?.dateText) - parseDateMs(b?.dateISO || b?.dateTime || b?.date || b?.dateText)));
    return g;
  }

  // ---------- render ----------
  function renderStats(){
    const focus = state.focusTeam;
    const opp = state.selectedOpponent ? norm(state.selectedOpponent) : "";
    const games = getGames();
    const roundDisplay = state.selectedRound !== null ? displayRound(state.selectedRound) : "—";

    const last = lastGameForTeam(focus, games);
    const lastVs = opp ? lastGameBetween(focus, opp, games) : null;

    const lastLine = last
      ? `משחק אחרון של גליל: <b>${opponentOf(last, focus)}</b> — <b>${scoreText(last)}</b> <span class="muted">(${formatDateHeb(last)})</span>`
      : `משחק אחרון של גליל: <span class="muted">אין תוצאה</span>`;

    const lastVsLine = opp
      ? (lastVs
        ? `מפגש אחרון מול <b>${opp}</b>: <b>${scoreText(lastVs)}</b> <span class="muted">(${formatDateHeb(lastVs)})</span>`
        : `מפגש אחרון מול <b>${opp}</b>: <span class="muted">אין תוצאה</span>`)
      : `יריבה נבחרת: <span class="muted">לא נבחרה</span>`;

    const shown = filteredGames().length;

    el("statsBox").innerHTML = [
      `קבוצה במרכז: <b>${focus || "—"}</b>`,
      `מחזור נבחר: <b>${roundDisplay}</b>`,
      opp ? `יריבה נבחרת: <b>${opp}</b>` : `יריבה נבחרת: <span class="muted">לא נבחרה</span>`,
      `משחקים בטבלה: <b>${shown}</b>`,
      lastLine,
      lastVsLine
    ].join("<br/>");
  }

  function renderGamesTable(){
    const tbl = el("gamesTable");
    const g = filteredGames();
    const focus = state.focusTeam;
    const opp = state.selectedOpponent ? norm(state.selectedOpponent) : "";

    el("tablesHint").textContent = opp
      ? `משחקים בין ${focus} ל-${opp} (כל המחזורים) • מוצגים: ${g.length}`
      : `משחקים במחזור הנבחר (או לפי הסינון) • מוצגים: ${g.length}`;

    const head = `<thead><tr>
      <th>מחזור</th><th>תאריך</th><th>בית</th><th>תוצאה</th><th>חוץ</th><th>מיקום</th>
    </tr></thead>`;
    const rows = [];
    for(const game of g){
      const r = game?.round?.number !== undefined ? displayRound(game.round.number) : "—";
      const home = teamNameFromGame(game,"home");
      const away = teamNameFromGame(game,"away");
      const loc = norm(game?.field?.name || game?.location || game?.venue || "");
      const date = formatDateHeb(game);

      rows.push(`<tr>
        <td>${r}</td>
        <td dir="rtl">${date}</td>
        <td><b>${home}</b></td>
        <td><b>${scoreText(game)}</b></td>
        <td><b>${away}</b></td>
        <td class="muted">${loc || "—"}</td>
      </tr>`);
    }
    tbl.innerHTML = head + `<tbody>${rows.join("")}</tbody>`;
  }

  function computeStandingsFromGames(){
    const games = getGames();
    const map = new Map(); // canon name -> stats
    const get = (name) => {
      const key = canon(name);
      if(!key) return null;
      if(!map.has(key)){
        map.set(key, { name: norm(name), played:0, w:0, d:0, l:0, gf:0, ga:0, gd:0, points:0 });
      }
      return map.get(key);
    };

    for(const g of games){
      const home = teamNameFromGame(g,"home");
      const away = teamNameFromGame(g,"away");
      if(!home || !away) continue;

      const {hsNum, asNum} = scoreNums(g);
      if(hsNum === null || asNum === null) continue;

      const H = get(home), A = get(away);
      if(!H || !A) continue;
      H.played++; A.played++;
      H.gf += hsNum; H.ga += asNum;
      A.gf += asNum; A.ga += hsNum;

      // Israeli youth leagues often 2 points win, 1 draw
      if(hsNum > asNum){ H.w++; A.l++; H.points += 2; }
      else if(hsNum < asNum){ A.w++; H.l++; A.points += 2; }
      else { H.d++; A.d++; H.points += 1; A.points += 1; }
    }

    const arr = Array.from(map.values()).map(r => ({...r, gd: r.gf - r.ga}));
    arr.sort((a,b) => (b.points-a.points) || (b.gd-a.gd) || (b.gf-a.gf) || a.name.localeCompare(b.name,"he"));
    arr.forEach((r,i)=> r.rank = i+1);
    return arr;
  }

  function renderStandingsTable(){
    const tbl = el("standingsTable");
    const focus = state.focusTeam;

    // Prefer standings from file; else compute from games (works even when file doesn't have standings)
    let s = getStandings();
    if(!s.length){
      s = computeStandingsFromGames();
    } else {
      // normalize keys
      s = s.map(r => ({
        name: norm(r.name),
        rank: r.rank ?? r.position ?? r.place ?? "",
        points: r.points ?? r.pts ?? r.p ?? "",
        played: r.games ?? r.played ?? r.matches ?? "",
        w: r.w ?? r.win ?? "",
        l: r.l ?? r.loss ?? "",
        d: r.d ?? r.draw ?? "",
        gf: r.gf ?? r.for ?? r.goals_for ?? "",
        ga: r.ga ?? r.against ?? r.goals_against ?? "",
        gd: r.gd ?? ((Number(r.gf)||0) - (Number(r.ga)||0)),
      }));
    }

    const head = `<thead><tr>
      <th>#</th><th>קבוצה</th><th>נק'</th><th>מש</th><th>נ</th><th>ת</th><th>ה</th><th>+</th><th>-</th><th>הפרש</th>
    </tr></thead>`;
    const rows = [];
    for(const r of s){
      const isFocus = focus && matchTeam(r.name, focus);
      rows.push(`<tr class="${isFocus ? "focusRow" : ""}">
        <td>${r.rank ?? ""}</td>
        <td><b>${r.name}</b></td>
        <td><b>${r.points ?? ""}</b></td>
        <td>${r.played ?? ""}</td>
        <td>${r.w ?? ""}</td>
        <td>${r.d ?? ""}</td>
        <td>${r.l ?? ""}</td>
        <td>${r.gf ?? ""}</td>
        <td>${r.ga ?? ""}</td>
        <td>${r.gd ?? ""}</td>
      </tr>`);
    }
    tbl.innerHTML = head + `<tbody>${rows.join("")}</tbody>`;
  }

  function renderMap(){
    const nodesEl = el("nodes");
    const linesEl = el("lines");
    nodesEl.innerHTML = "";
    linesEl.innerHTML = "";

    const teams = uniqueTeams();
    const focus = state.focusTeam;
    if(!teams.length){
      // If standings missing, still try to build from games
      const gs = getGames();
      const fromGames = [];
      const seen = new Set();
      for(const g of gs){
        for(const t of [teamNameFromGame(g,"home"), teamNameFromGame(g,"away")]){
          const k = canon(t);
          if(k && !seen.has(k)){ seen.add(k); fromGames.push(norm(t)); }
        }
      }
      teams.push(...fromGames.filter(t => !teams.some(x => matchTeam(x,t))));
    }
    if(!teams.length) return;

    // Center node
    const center = document.createElement("div");
    center.className = "node center";
    center.style.left = "50%";
    center.style.top = "55%";

    const standings = getStandings();
    const row = standings.find(x => matchTeam(x?.name, focus));
    const pts = row?.points ?? row?.pts ?? "—";
    const rank = row?.rank ?? row?.position ?? "—";

    center.innerHTML = `<div class="name">${focus}</div>
      <div class="meta"><span>מקום ${rank}</span><span>${pts} נק׳</span></div>
      <div class="cta">הקבוצה שלנו (לחץ לאיפוס יריבה)</div>`;
    center.onclick = () => { state.selectedOpponent = ""; state.chipTeam = ""; renderAll(); };
    nodesEl.appendChild(center);

    const others = teams.filter(t => !matchTeam(t, focus));
    const count = others.length || 1;

    const radiusX = 310;
    const radiusY = 230;
    const cx = 0.5, cy = 0.55;

    function pos(i){
      const a = (i / count) * Math.PI * 2;
      const x = cx + (Math.cos(a) * radiusX) / 1000;
      const y = cy + (Math.sin(a) * radiusY) / 720;
      return {x: x*100, y: y*100};
    }

    const games = getGames();

    others.forEach((team, i) => {
      const p = pos(i);
      const left = `${p.x}%`;
      const top  = `${p.y}%`;

      const st = standings.find(x => matchTeam(x?.name, team));
      const lastVs = lastGameBetween(focus, team, games);

      const lastLine = lastVs
        ? `מפגש אחרון: ${scoreText(lastVs)} • ${formatDateHeb(lastVs)}`
        : `מפגש אחרון: אין תוצאה`;

      // line
      const line = document.createElement("div");
      line.className = "line";
      line.dataset.to = JSON.stringify({x:left, y:top});
      linesEl.appendChild(line);

      const d = document.createElement("div");
      const active = state.selectedOpponent && matchTeam(state.selectedOpponent, team);
      d.className = "node" + (active ? " active" : "");
      d.style.left = left;
      d.style.top = top;

      d.innerHTML = `<div class="name">${team}</div>
        <div class="meta"><span>מקום ${st?.rank ?? st?.position ?? "—"}</span><span>${st?.points ?? st?.pts ?? "—"} נק׳</span></div>
        <div class="meta2">${lastLine}</div>
        <div class="cta">לחץ לסינון היריבה</div>`;

      d.onclick = () => { state.selectedOpponent = team; state.chipTeam = team; renderAll(); };
      nodesEl.appendChild(d);
    });

    // position lines after layout
    requestAnimationFrame(() => {
      const map = document.querySelector(".mapInner");
      const rect = map.getBoundingClientRect();
      const centerX = rect.width * 0.5;
      const centerY = rect.height * 0.55;

      for(const line of linesEl.querySelectorAll(".line")){
        const to = JSON.parse(line.dataset.to);
        const xPct = parseFloat(String(to.x).replace("%",""))/100;
        const yPct = parseFloat(String(to.y).replace("%",""))/100;
        const x2 = rect.width * xPct;
        const y2 = rect.height * yPct;
        const dx = x2 - centerX, dy = y2 - centerY;
        const len = Math.sqrt(dx*dx + dy*dy);
        const ang = Math.atan2(dy, dx);
        line.style.left = centerX + "px";
        line.style.top = centerY + "px";
        line.style.width = len + "px";
        line.style.transform = `rotate(${ang}rad)`;
      }
    });
  }

  function renderAll(){
    state.onlyTeam = el("onlyTeam").checked;

    // defensive: if focus empty, resolve
    if(!state.focusTeam){
      state.focusTeam = resolveFocusTeam();
    }

    renderStats();
    renderGamesTable();
    renderStandingsTable();
    renderMap();
    buildChips();

    const m = getMeta();
    const metaBits = [];
    if(m.version) metaBits.push("v" + m.version);
    if(m.fetchedAt) metaBits.push(m.fetchedAt);
    el("metaSmall").textContent = metaBits.join(" • ") || "—";
  }

  function setup(){
    el("onlyTeam").checked = true;

    el("toggleGames").onclick = () => {
      el("gamesWrap").style.display = "block";
      el("standingsWrap").style.display = "none";
      el("toggleGames").classList.add("primary");
      el("toggleStandings").classList.remove("primary");
    };
    el("toggleStandings").onclick = () => {
      el("gamesWrap").style.display = "none";
      el("standingsWrap").style.display = "block";
      el("toggleStandings").classList.add("primary");
      el("toggleGames").classList.remove("primary");
    };
    el("resetBtn").onclick = () => {
      state.selectedOpponent = "";
      state.chipTeam = "";
      el("teamInput").value = "";
      el("onlyTeam").checked = true;
      renderAll();
    };
    el("teamInput").addEventListener("input", () => renderAll());
    el("onlyTeam").addEventListener("change", () => renderAll());
  }

  async function fetchJson(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error(`HTTP ${res.status} (${url})`);
    return res.json();
  }

  async function load(){
    setup();
    try{
      let usedUrl = PRIMARY_DATA_URL;
      let data;
      try{
        data = await fetchJson(PRIMARY_DATA_URL);
      } catch(e1){
        // fallback to sample
        data = await fetchJson(FALLBACK_DATA_URL);
        usedUrl = FALLBACK_DATA_URL;
        setWarn(`הערה: לא נמצא ${PRIMARY_DATA_URL}, נטענו נתוני דוגמה (${FALLBACK_DATA_URL}). ב-GitHub Pages אמור להיות ${PRIMARY_DATA_URL}.`);
      }

      state.data = data;

      // resolve focus team from standings/games
      state.focusTeam = resolveFocusTeam();

      // rounds: support old schema and new schema
      const meta = data.meta || {};
      if(Array.isArray(meta.roundsFetched) && meta.roundsFetched.length){
        state.rounds = meta.roundsFetched.map(r => ({ number: String(r.number), gamesCount: Number(r.gamesCount || 0) }));
      } else if(Array.isArray(data.rounds) && data.rounds.length){
        state.rounds = data.rounds.map(r => ({ number: String(r.number), gamesCount: Number(r.gamesCount || 0) }));
      } else {
        // derive from games
        const by = new Map();
        for(const g of getGames()){
          const n = String(g?.round?.number ?? "");
          if(!n) continue;
          by.set(n, (by.get(n) || 0) + 1);
        }
        state.rounds = Array.from(by.entries()).map(([number, gamesCount]) => ({ number, gamesCount }))
          .sort((a,b) => Number(a.number) - Number(b.number));
      }

      computeRoundOffset();
      buildRoundSelect();

      el("leagueLine").textContent = leagueLine();
      el("sourceLine").textContent = `מקור: ${usedUrl === PRIMARY_DATA_URL ? "GitHub Pages" : "דוגמה מקומית"}`;

      renderAll();
      setErr("");
    } catch(e){
      console.error(e);
      setWarn("");
      setErr(
`לא הצלחתי לטעון נתונים.
ודא ש-${PRIMARY_DATA_URL} קיים בשורש הריפו (אותיות קטנות בדיוק) ושאין שגיאות בקונסול.
שגיאה: ${e?.message || e}`
      );
      el("leagueLine").textContent = "שגיאה בטעינה";
    }
  }

  load();
})();
</script>
</body>
</html>
